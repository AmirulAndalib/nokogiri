# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `libxml-ruby` gem.
# Please instead update this file by running `bin/tapioca gem libxml-ruby`.

# source://libxml-ruby//lib/libxml/error.rb#3
module LibXML; end

# source://libxml-ruby//lib/libxml/error.rb#4
module LibXML::XML
  private

  def catalog_dump; end
  def catalog_remove(_arg0); end
  def check_lib_versions; end
  def debug_entities; end
  def debug_entities=(_arg0); end
  def default_compression; end
  def default_compression=(_arg0); end
  def default_keep_blanks; end
  def default_keep_blanks=(_arg0); end
  def default_line_numbers; end
  def default_line_numbers=(_arg0); end
  def default_load_external_dtd; end
  def default_load_external_dtd=(_arg0); end
  def default_options; end
  def default_pedantic_parser; end
  def default_pedantic_parser=(_arg0); end
  def default_save_no_empty_tags; end
  def default_save_no_empty_tags=(_arg0); end
  def default_substitute_entities; end
  def default_substitute_entities=(_arg0); end
  def default_tree_indent_string; end
  def default_tree_indent_string=(_arg0); end
  def default_validity_checking; end
  def default_validity_checking=(_arg0); end
  def default_warnings; end
  def default_warnings=(_arg0); end
  def enabled_automata?; end
  def enabled_c14n?; end
  def enabled_catalog?; end
  def enabled_debug?; end
  def enabled_docbook?; end
  def enabled_ftp?; end
  def enabled_html?; end
  def enabled_http?; end
  def enabled_iconv?; end
  def enabled_memory_debug?; end
  def enabled_regexp?; end
  def enabled_schemas?; end
  def enabled_thread?; end
  def enabled_unicode?; end
  def enabled_xinclude?; end
  def enabled_xpath?; end
  def enabled_xpointer?; end
  def enabled_zlib?; end
  def features; end
  def indent_tree_output; end
  def indent_tree_output=(_arg0); end
  def memory_dump; end
  def memory_used; end

  class << self
    def catalog_dump; end
    def catalog_remove(_arg0); end
    def check_lib_versions; end
    def debug_entities; end
    def debug_entities=(_arg0); end
    def default_compression; end
    def default_compression=(_arg0); end
    def default_keep_blanks; end
    def default_keep_blanks=(_arg0); end
    def default_line_numbers; end
    def default_line_numbers=(_arg0); end
    def default_load_external_dtd; end
    def default_load_external_dtd=(_arg0); end
    def default_options; end
    def default_pedantic_parser; end
    def default_pedantic_parser=(_arg0); end
    def default_save_no_empty_tags; end
    def default_save_no_empty_tags=(_arg0); end
    def default_substitute_entities; end
    def default_substitute_entities=(_arg0); end
    def default_tree_indent_string; end
    def default_tree_indent_string=(_arg0); end
    def default_validity_checking; end
    def default_validity_checking=(_arg0); end
    def default_warnings; end
    def default_warnings=(_arg0); end
    def enabled_automata?; end
    def enabled_c14n?; end
    def enabled_catalog?; end
    def enabled_debug?; end
    def enabled_docbook?; end
    def enabled_ftp?; end
    def enabled_html?; end
    def enabled_http?; end
    def enabled_iconv?; end
    def enabled_memory_debug?; end
    def enabled_regexp?; end
    def enabled_schemas?; end
    def enabled_thread?; end
    def enabled_unicode?; end
    def enabled_xinclude?; end
    def enabled_xpath?; end
    def enabled_xpointer?; end
    def enabled_zlib?; end
    def features; end
    def indent_tree_output; end
    def indent_tree_output=(_arg0); end
    def memory_dump; end
    def memory_used; end
  end
end

# source://libxml-ruby//lib/libxml/attr.rb#5
class LibXML::XML::Attr
  include ::Enumerable

  def initialize(*_arg0); end

  def child; end

  # call-seq:
  #    attr.child? -> (true|false)
  #
  # Returns whether this attribute has child attributes.
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/attr.rb#13
  def child?; end

  def doc; end

  # call-seq:
  #    attr.doc? -> (true|false)
  #
  # Determine whether this attribute is associated with an
  # XML::Document.
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/attr.rb#22
  def doc?; end

  # source://libxml-ruby//lib/libxml/attr.rb#97
  def each(&blk); end

  # source://libxml-ruby//lib/libxml/attr.rb#97
  def each_attr(&blk); end

  # source://libxml-ruby//lib/libxml/attr.rb#97
  def each_sibling(&blk); end

  def last; end

  # call-seq:
  #    attr.last? -> (true|false)
  #
  # Determine whether this is the last attribute.
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/attr.rb#30
  def last?; end

  def name; end

  # call-seq:
  #   attr.namespacess -> XML::Namespaces
  #
  # Returns this node's XML::Namespaces object,
  # which is used to access the namespaces
  # associated with this node.
  #
  # source://libxml-ruby//lib/libxml/attr.rb#57
  def namespaces; end

  def next; end

  # call-seq:
  #    attr.next? -> (true|false)
  #
  # Determine whether there is a next attribute.
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/attr.rb#38
  def next?; end

  def node_type; end

  # Returns this node's type name
  #
  # source://libxml-ruby//lib/libxml/attr.rb#79
  def node_type_name; end

  def ns; end

  # call-seq:
  #    attr.ns? -> (true|false)
  #
  # Determine whether this attribute has an associated
  # namespace.
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/attr.rb#47
  def ns?; end

  def parent; end

  # call-seq:
  #    attr.parent? -> (true|false)
  #
  # Determine whether this attribute has a parent.
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/attr.rb#66
  def parent?; end

  def prev; end

  # call-seq:
  #    attr.prev? -> (true|false)
  #
  # Determine whether there is a previous attribute.
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/attr.rb#74
  def prev?; end

  def remove!; end

  # Iterates nodes and attributes
  #
  # source://libxml-ruby//lib/libxml/attr.rb#88
  def siblings(node, &blk); end

  # source://libxml-ruby//lib/libxml/attr.rb#111
  def to_a; end

  # source://libxml-ruby//lib/libxml/attr.rb#104
  def to_h; end

  # source://libxml-ruby//lib/libxml/attr.rb#118
  def to_s; end

  def value; end
  def value=(_arg0); end
end

# source://libxml-ruby//lib/libxml/attr_decl.rb#5
class LibXML::XML::AttrDecl
  include ::Enumerable

  # call-seq:
  #   attr_decl.child -> nil
  #
  # Obtain this attribute declaration's child attribute(s).
  # It will always be nil.
  #
  # source://libxml-ruby//lib/libxml/attr_decl.rb#13
  def child; end

  # call-seq:
  #    attr_decl.child? -> (true|false)
  #
  # Returns whether this attribute declaration has child attributes.
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/attr_decl.rb#22
  def child?; end

  def doc; end

  # call-seq:
  #    attr_decl.doc? -> (true|false)
  #
  # Determine whether this attribute declaration is associated with an
  # XML::Document.
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/attr_decl.rb#31
  def doc?; end

  def name; end
  def next; end

  # call-seq:
  #    attr_decl.next? -> (true|false)
  #
  # Determine whether there is a next attribute declaration.
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/attr_decl.rb#39
  def next?; end

  def node_type; end

  # call-seq:
  #    attr_decl.node_type_name -> 'attribute declaration'
  #
  # Returns this attribute declaration's node type name.
  #
  # source://libxml-ruby//lib/libxml/attr_decl.rb#63
  def node_type_name; end

  def parent; end

  # call-seq:
  #    attr_decl.parent? -> (true|false)
  #
  # Determine whether this attribute declaration has a parent .
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/attr_decl.rb#47
  def parent?; end

  def prev; end

  # call-seq:
  #    attr_decl.prev? -> (true|false)
  #
  # Determine whether there is a previous attribute declaration.
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/attr_decl.rb#55
  def prev?; end

  # call-seq:
  #    attr_decl.to_s -> string
  #
  # Returns a string representation of this attribute declaration.
  #
  # source://libxml-ruby//lib/libxml/attr_decl.rb#75
  def to_s; end

  def value; end
end

# source://libxml-ruby//lib/libxml/attributes.rb#5
class LibXML::XML::Attributes
  include ::Enumerable

  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def each; end
  def first; end
  def get_attribute(_arg0); end
  def get_attribute_ns(_arg0, _arg1); end
  def length; end
  def node; end

  # source://libxml-ruby//lib/libxml/attributes.rb#6
  def to_h; end
end

# source://libxml-ruby//lib/libxml/document.rb#5
class LibXML::XML::Document
  def initialize(*_arg0); end

  def canonicalize(*_arg0); end
  def child; end
  def child?; end
  def compression; end
  def compression=(_arg0); end
  def compression?; end

  # Returns a new XML::XPathContext for the document.
  #
  # call-seq:
  #   document.context(namespaces=nil) -> XPath::Context
  #
  # Namespaces is an optional array of XML::NS objects
  #
  # source://libxml-ruby//lib/libxml/document.rb#85
  def context(nslist = T.unsafe(nil)); end

  def debug; end

  # source://libxml-ruby//lib/libxml/document.rb#173
  def debug_dump; end

  # source://libxml-ruby//lib/libxml/document.rb#178
  def debug_dump_head; end

  # source://libxml-ruby//lib/libxml/document.rb#183
  def debug_format_dump; end

  # Specifies if this is an docbook node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/document.rb#154
  def docbook_doc?; end

  # Specifies if this is an document node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/document.rb#149
  def document?; end

  # source://libxml-ruby//lib/libxml/document.rb#163
  def dump; end

  def encoding; end
  def encoding=(_arg0); end

  # Return the nodes matching the specified xpath expression,
  # optionally using the specified namespace.  For more
  # information about working with namespaces, please refer
  # to the XML::XPath documentation.
  #
  # call-seq:
  #   document.find(xpath, nslist=nil) -> XML::XPath::Object
  #
  # Parameters:
  # * xpath - The xpath expression as a string
  # * namespaces - An optional list of namespaces (see XML::XPath for information).
  #
  #  document.find('/foo', 'xlink:http://www.w3.org/1999/xlink')
  #
  # IMPORTANT - The returned XML::Node::Set must be freed before
  # its associated document.  In a running Ruby program this will
  # happen automatically via Ruby's mark and sweep garbage collector.
  # However, if the program exits, Ruby does not guarantee the order
  # in which objects are freed
  # (see http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/17700).
  # As a result, the associated document may be freed before the node
  # list, which will cause a segmentation fault.
  # To avoid this, use the following (non-ruby like) coding style:
  #
  #  nodes = doc.find('/header')
  #  nodes.each do |node|
  #    ... do stuff ...
  #  end
  # #  nodes = nil #  GC.start
  #
  # source://libxml-ruby//lib/libxml/document.rb#122
  def find(xpath, nslist = T.unsafe(nil)); end

  # Return the first node matching the specified xpath expression.
  # For more information, please refer to the documentation
  # for XML::Document#find.
  #
  # source://libxml-ruby//lib/libxml/document.rb#129
  def find_first(xpath, nslist = T.unsafe(nil)); end

  # source://libxml-ruby//lib/libxml/document.rb#168
  def format_dump; end

  # Specifies if this is an html node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/document.rb#159
  def html_doc?; end

  def import(_arg0); end
  def last; end
  def last?; end
  def next; end
  def next?; end
  def node_type; end

  # Returns this node's type name
  #
  # source://libxml-ruby//lib/libxml/document.rb#134
  def node_type_name; end

  def order_elements!; end
  def parent; end
  def parent?; end
  def prev; end
  def prev?; end
  def rb_encoding; end

  # source://libxml-ruby//lib/libxml/document.rb#188
  def reader; end

  def root; end
  def root=(_arg0); end
  def save(*_arg0); end
  def standalone?; end
  def to_s(*_arg0); end
  def url; end
  def validate(_arg0); end
  def validate_relaxng(_arg0); end
  def validate_schema(_arg0); end
  def version; end
  def xhtml?; end
  def xinclude; end

  class << self
    # call-seq:
    #    XML::Document.document(document) -> XML::Document
    #
    # Creates a new document based on the specified document.
    #
    # Parameters:
    #
    #  document - A preparsed document.
    #
    # source://libxml-ruby//lib/libxml/document.rb#14
    def document(value); end

    # call-seq:
    #    XML::Document.file(path) -> XML::Document
    #    XML::Document.file(path, :encoding => XML::Encoding::UTF_8,
    #                             :options => XML::Parser::Options::NOENT) -> XML::Document
    #
    # Creates a new document from the specified file or uri.
    #
    # You may provide an optional hash table to control how the
    # parsing is performed.  Valid options are:
    #
    #  encoding - The document encoding, defaults to nil. Valid values
    #             are the encoding constants defined on XML::Encoding.
    #  options - Parser options.  Valid values are the constants defined on
    #            XML::Parser::Options.  Mutliple options can be combined
    #            by using Bitwise OR (|).
    #
    # source://libxml-ruby//lib/libxml/document.rb#33
    def file(value, options = T.unsafe(nil)); end

    # call-seq:
    #    XML::Document.io(io) -> XML::Document
    #    XML::Document.io(io, :encoding => XML::Encoding::UTF_8,
    #                         :options => XML::Parser::Options::NOENT
    #                         :base_uri="http://libxml.org") -> XML::Document
    #
    # Creates a new document from the specified io object.
    #
    # Parameters:
    #
    #  io - io object that contains the xml to parser
    #  base_uri - The base url for the parsed document.
    #  encoding - The document encoding, defaults to nil. Valid values
    #             are the encoding constants defined on XML::Encoding.
    #  options - Parser options.  Valid values are the constants defined on
    #            XML::Parser::Options.  Mutliple options can be combined
    #            by using Bitwise OR (|).
    #
    # source://libxml-ruby//lib/libxml/document.rb#54
    def io(value, options = T.unsafe(nil)); end

    # call-seq:
    #    XML::Document.string(string) -> XML::Document
    #    XML::Document.string(string, :encoding => XML::Encoding::UTF_8,
    #                               :options => XML::Parser::Options::NOENT
    #                               :base_uri="http://libxml.org") -> XML::Document
    #
    # Creates a new document from the specified string.
    #
    # You may provide an optional hash table to control how the
    # parsing is performed.  Valid options are:
    #
    #   base_uri - The base url for the parsed document.
    #   encoding - The document encoding, defaults to nil. Valid values
    #              are the encoding constants defined on XML::Encoding.
    #   options  - Parser options.  Valid values are the constants defined on
    #              XML::Parser::Options.  Mutliple options can be combined
    #              by using Bitwise OR (|).
    #
    # source://libxml-ruby//lib/libxml/document.rb#75
    def string(value, options = T.unsafe(nil)); end
  end
end

LibXML::XML::Document::XML_C14N_1_0 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Document::XML_C14N_1_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Document::XML_C14N_EXCLUSIVE_1_0 = T.let(T.unsafe(nil), Integer)

class LibXML::XML::Dtd
  def initialize(*_arg0); end

  def external_id; end
  def name; end
  def node_type; end
  def system_id; end
  def uri; end
end

module LibXML::XML::Encoding
  private

  def from_s(_arg0); end
  def to_rb_encoding(_arg0, _arg1); end
  def to_s(_arg0); end

  class << self
    def from_s(_arg0); end
    def to_rb_encoding(_arg0, _arg1); end
    def to_s(_arg0); end
  end
end

LibXML::XML::Encoding::ASCII = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::EBCDIC = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::EUC_JP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::ISO_2022_JP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::ISO_8859_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::ISO_8859_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::ISO_8859_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::ISO_8859_4 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::ISO_8859_5 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::ISO_8859_6 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::ISO_8859_7 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::ISO_8859_8 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::ISO_8859_9 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::NONE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::SHIFT_JIS = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::UCS_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::UCS_4BE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::UCS_4LE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::UCS_4_2143 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::UCS_4_3412 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::UTF_16BE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::UTF_16LE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Encoding::UTF_8 = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/error.rb#5
class LibXML::XML::Error < ::StandardError
  # source://libxml-ruby//lib/libxml/error.rb#37
  def ==(other); end

  def code; end

  # source://libxml-ruby//lib/libxml/error.rb#76
  def code_to_s; end

  def ctxt; end
  def domain; end

  # source://libxml-ruby//lib/libxml/error.rb#72
  def domain_to_s; end

  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/error.rb#41
  def eql?(other); end

  def file; end
  def int1; end
  def int2; end
  def level; end

  # source://libxml-ruby//lib/libxml/error.rb#59
  def level_to_s; end

  def line; end
  def node; end
  def str1; end
  def str2; end
  def str3; end

  # source://libxml-ruby//lib/libxml/error.rb#80
  def to_s; end

  class << self
    def get_handler; end
    def reset_handler; end
    def set_handler; end
  end
end

LibXML::XML::Error::ATTLIST_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ATTLIST_NOT_STARTED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ATTRIBUTE_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ATTRIBUTE_NOT_STARTED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ATTRIBUTE_REDEFINED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ATTRIBUTE_WITHOUT_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::C14N = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::C14N_CREATE_CTXT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::C14N_CREATE_STACK = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::C14N_INVALID_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::C14N_RELATIVE_NAMESPACE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::C14N_REQUIRES_UTF8 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::C14N_UNKNOW_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CATALOG = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CATALOG_ENTRY_BROKEN = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CATALOG_MISSING_ATTR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CATALOG_NOT_CATALOG = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CATALOG_PREFER_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CATALOG_RECURSION = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CDATA_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHARREF_AT_EOF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHARREF_IN_DTD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHARREF_IN_EPILOG = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHARREF_IN_PROLOG = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_ENTITY_TYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_FOUND_ATTRIBUTE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_FOUND_CDATA = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_FOUND_COMMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_FOUND_DOCTYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_FOUND_ELEMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_FOUND_ENTITY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_FOUND_ENTITYREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_FOUND_FRAGMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_FOUND_NOTATION = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_FOUND_PI = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_FOUND_TEXT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NAME_NOT_NULL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NOT_ATTR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NOT_ATTR_DECL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NOT_DTD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NOT_ELEM_DECL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NOT_ENTITY_DECL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NOT_NCNAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NOT_NS_DECL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NOT_UTF8 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NO_DICT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NO_DOC = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NO_ELEM = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NO_HREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NO_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NO_NEXT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NO_PARENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NO_PREV = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NS_ANCESTOR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_NS_SCOPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_OUTSIDE_DICT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_UNKNOWN_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_WRONG_DOC = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_WRONG_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_WRONG_NEXT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_WRONG_PARENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CHECK_WRONG_PREV = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::COMMENT_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CONDSEC_INVALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CONDSEC_INVALID_KEYWORD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CONDSEC_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::CONDSEC_NOT_STARTED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DATATYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DOCTYPE_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DOCUMENT_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DOCUMENT_END = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DOCUMENT_START = T.let(T.unsafe(nil), Integer)

# Create mapping from domain constant value to keys
#
# source://libxml-ruby//lib/libxml/error.rb#7
LibXML::XML::Error::DOMAIN_CODE_MAP = T.let(T.unsafe(nil), Hash)

LibXML::XML::Error::DTD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_ATTRIBUTE_DEFAULT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_ATTRIBUTE_REDEFINED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_ATTRIBUTE_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_CONTENT_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_CONTENT_MODEL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_CONTENT_NOT_DETERMINIST = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_DIFFERENT_PREFIX = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_ELEM_DEFAULT_NAMESPACE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_ELEM_NAMESPACE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_ELEM_REDEFINED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_EMPTY_NOTATION = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_ENTITY_TYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_ID_FIXED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_ID_REDEFINED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_ID_SUBSET = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_INVALID_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_INVALID_DEFAULT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_LOAD_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_MISSING_ATTRIBUTE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_MIXED_CORRUPT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_MULTIPLE_ID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_NOTATION_REDEFINED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_NOTATION_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_NOT_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_NOT_PCDATA = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_NOT_STANDALONE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_NO_DOC = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_NO_DTD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_NO_ELEM_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_NO_PREFIX = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_NO_ROOT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_ROOT_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_STANDALONE_DEFAULTED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_STANDALONE_WHITE_SPACE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_UNKNOWN_ATTRIBUTE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_UNKNOWN_ELEM = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_UNKNOWN_ENTITY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_UNKNOWN_ID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_UNKNOWN_NOTATION = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_XMLID_TYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::DTD_XMLID_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ELEMCONTENT_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ELEMCONTENT_NOT_STARTED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENCODING_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITYREF_AT_EOF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITYREF_IN_DTD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITYREF_IN_EPILOG = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITYREF_IN_PROLOG = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITYREF_NO_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITYREF_SEMICOL_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITY_BOUNDARY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITY_CHAR_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITY_IS_EXTERNAL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITY_IS_PARAMETER = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITY_LOOP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITY_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITY_NOT_STARTED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITY_PE_INTERNAL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ENTITY_PROCESSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::EQUAL_REQUIRED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::ERROR = T.let(T.unsafe(nil), Integer)

# Create mapping from domain constant value to keys
#
# source://libxml-ruby//lib/libxml/error.rb#18
LibXML::XML::Error::ERROR_CODE_MAP = T.let(T.unsafe(nil), Hash)

LibXML::XML::Error::EXTRA_CONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::EXT_ENTITY_STANDALONE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::EXT_SUBSET_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::FATAL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::FTP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::FTP_ACCNT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::FTP_EPSV_ANSWER = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::FTP_PASV_ANSWER = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::FTP_URL_SYNTAX = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::GT_REQUIRED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::HTML = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::HTML_STRUCURE_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::HTML_UNKNOWN_TAG = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::HTTP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::HTTP_UNKNOWN_HOST = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::HTTP_URL_SYNTAX = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::HTTP_USE_IP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::HYPHEN_IN_COMMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::I18N = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::I18N_CONV_FAILED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::I18N_EXCESS_HANDLER = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::I18N_NO_HANDLER = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::I18N_NO_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::I18N_NO_OUTPUT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::INVALID_CHAR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::INVALID_CHARREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::INVALID_DEC_CHARREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::INVALID_ENCODING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::INVALID_HEX_CHARREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::INVALID_URI = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_BUFFER_FULL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EACCES = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EADDRINUSE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EAFNOSUPPORT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EAGAIN = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EALREADY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EBADF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EBADMSG = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EBUSY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ECANCELED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ECHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ECONNREFUSED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EDEADLK = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EDOM = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EEXIST = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EFAULT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EFBIG = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EINPROGRESS = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EINTR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EINVAL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EIO = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EISCONN = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EISDIR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EMFILE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EMLINK = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EMSGSIZE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENAMETOOLONG = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENCODER = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENETUNREACH = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENFILE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENODEV = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENOENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENOEXEC = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENOLCK = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENOMEM = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENOSPC = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENOSYS = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENOTDIR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENOTEMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENOTSOCK = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENOTSUP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENOTTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ENXIO = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EPERM = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EPIPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ERANGE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EROFS = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ESPIPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ESRCH = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_ETIMEDOUT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_EXDEV = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_FLUSH = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_LOAD_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_NETWORK_ATTEMPT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_NO_INPUT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_UNKNOWN = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::IO_WRITE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::LITERAL_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::LITERAL_NOT_STARTED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::LTSLASH_REQUIRED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::LT_IN_ATTRIBUTE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::LT_REQUIRED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::MEMORY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::MISPLACED_CDATA_END = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::MISSING_ENCODING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::MIXED_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::MIXED_NOT_STARTED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::MODULE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::MODULE_CLOSE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::MODULE_OPEN = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NAMESPACE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NAME_REQUIRED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NMTOKEN_REQUIRED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NONE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NOTATION_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NOTATION_NOT_STARTED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NOTATION_PROCESSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NOT_STANDALONE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NOT_WELL_BALANCED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NO_DTD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NO_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NO_MEMORY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NS_DECL_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NS_ERR_ATTRIBUTE_REDEFINED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NS_ERR_COLON = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NS_ERR_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NS_ERR_QNAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NS_ERR_UNDEFINED_NAMESPACE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::NS_ERR_XML_NAMESPACE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::OK = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::OUTPUT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::PARSER = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::PCDATA_REQUIRED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::PEREF_AT_EOF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::PEREF_IN_EPILOG = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::PEREF_IN_INT_SUBSET = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::PEREF_IN_PROLOG = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::PEREF_NO_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::PEREF_SEMICOL_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::PI_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::PI_NOT_STARTED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::PUBID_REQUIRED = T.let(T.unsafe(nil), Integer)

# Quiet error handler
#
# source://libxml-ruby//lib/libxml/error.rb#34
LibXML::XML::Error::QUIET_HANDLER = T.let(T.unsafe(nil), Proc)

LibXML::XML::Error::REGEXP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::REGEXP_COMPILE_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RELAXNGP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RELAXNGV = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RESERVED_XML_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_ANYNAME_ATTR_ANCESTOR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_ATTRIBUTE_CHILDREN = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_ATTRIBUTE_CONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_ATTRIBUTE_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_ATTRIBUTE_NOOP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_ATTR_CONFLICT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_CHOICE_CONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_CHOICE_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_CREATE_FAILURE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_DATA_CONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_DEFINE_CREATE_FAILED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_DEFINE_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_DEFINE_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_DEFINE_NAME_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_DEF_CHOICE_AND_INTERLEAVE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_ELEMENT_CONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_ELEMENT_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_ELEMENT_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_ELEMENT_NO_CONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_ELEM_CONTENT_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_ELEM_CONTENT_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_ELEM_TEXT_CONFLICT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_EMPTY_CONSTRUCT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_EMPTY_CONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_EMPTY_NOT_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_ERROR_TYPE_LIB = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_EXCEPT_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_EXCEPT_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_EXCEPT_MULTIPLE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_EXCEPT_NO_CONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_EXTERNALREF_EMTPY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_EXTERNALREF_RECURSE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_EXTERNAL_REF_FAILURE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_FORBIDDEN_ATTRIBUTE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_FOREIGN_ELEMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_GRAMMAR_CONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_GRAMMAR_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_GRAMMAR_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_GRAMMAR_NO_START = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_GROUP_ATTR_CONFLICT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_HREF_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_INCLUDE_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_INCLUDE_FAILURE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_INCLUDE_RECURSE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_INTERLEAVE_ADD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_INTERLEAVE_CREATE_FAILED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_INTERLEAVE_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_INTERLEAVE_NO_CONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_INVALID_DEFINE_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_INVALID_URI = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_INVALID_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_MISSING_HREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_NAME_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_NEED_COMBINE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_NOTALLOWED_NOT_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_NSNAME_ATTR_ANCESTOR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_NSNAME_NO_NS = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PARAM_FORBIDDEN = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PARAM_NAME_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PARENTREF_CREATE_FAILED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PARENTREF_NAME_INVALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PARENTREF_NOT_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PARENTREF_NO_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PARENTREF_NO_PARENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PARSE_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_ANYNAME_EXCEPT_ANYNAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_ATTR_ATTR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_ATTR_ELEM = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_DATA_EXCEPT_ATTR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_DATA_EXCEPT_ELEM = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_DATA_EXCEPT_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_DATA_EXCEPT_GROUP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_DATA_EXCEPT_INTERLEAVE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_DATA_EXCEPT_LIST = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_DATA_EXCEPT_ONEMORE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_DATA_EXCEPT_REF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_DATA_EXCEPT_TEXT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_LIST_ATTR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_LIST_ELEM = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_LIST_INTERLEAVE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_LIST_LIST = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_LIST_REF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_LIST_TEXT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_NSNAME_EXCEPT_ANYNAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_NSNAME_EXCEPT_NSNAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_ONEMORE_GROUP_ATTR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_ONEMORE_INTERLEAVE_ATTR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_START_ATTR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_START_DATA = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_START_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_START_GROUP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_START_INTERLEAVE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_START_LIST = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_START_ONEMORE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_START_TEXT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PAT_START_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_PREFIX_UNDEFINED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_REF_CREATE_FAILED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_REF_CYCLE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_REF_NAME_INVALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_REF_NOT_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_REF_NO_DEF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_REF_NO_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_START_CHOICE_AND_INTERLEAVE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_START_CONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_START_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_START_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_TEXT_EXPECTED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_TEXT_HAS_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_TYPE_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_TYPE_NOT_FOUND = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_TYPE_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_UNKNOWN_ATTRIBUTE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_UNKNOWN_COMBINE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_UNKNOWN_CONSTRUCT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_UNKNOWN_TYPE_LIB = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_URI_FRAGMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_URI_NOT_ABSOLUTE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_VALUE_EMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_VALUE_NO_CONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_XMLNS_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::RNGP_XML_NS = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SAVE_CHAR_INVALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SAVE_NOT_UTF8 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SAVE_NO_DOCTYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SAVE_UNKNOWN_ENCODING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_AG_PROPS_CORRECT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_ATTRFORMDEFAULT_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_ATTRGRP_NONAME_NOREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_ATTR_NONAME_NOREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_AU_PROPS_CORRECT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_AU_PROPS_CORRECT_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_A_PROPS_CORRECT_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_A_PROPS_CORRECT_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COMPLEXTYPE_NONAME_NOREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ALL_LIMITED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_CT_EXTENDS_1_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_CT_EXTENDS_1_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_CT_EXTENDS_1_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_DERIVED_OK_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_DERIVED_OK_2_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_1_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_1_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_1_3_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_1_3_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_2_3_1_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_2_3_1_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_2_3_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_2_3_2_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_2_3_2_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_2_3_2_4 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_2_3_2_5 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_3_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_3_3_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_3_3_1_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_3_3_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_3_3_2_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_3_3_2_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_3_3_2_4 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_ST_RESTRICTS_3_3_2_5 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_VALID_DEFAULT_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_VALID_DEFAULT_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_VALID_DEFAULT_2_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_COS_VALID_DEFAULT_2_2_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_CT_PROPS_CORRECT_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_CT_PROPS_CORRECT_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_CT_PROPS_CORRECT_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_CT_PROPS_CORRECT_4 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_CT_PROPS_CORRECT_5 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_CVC_SIMPLE_TYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_C_PROPS_CORRECT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_DEF_AND_PREFIX = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_DERIVATION_OK_RESTRICTION_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_DERIVATION_OK_RESTRICTION_2_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_DERIVATION_OK_RESTRICTION_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_DERIVATION_OK_RESTRICTION_4_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_DERIVATION_OK_RESTRICTION_4_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_DERIVATION_OK_RESTRICTION_4_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_ELEMFORMDEFAULT_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_ELEM_DEFAULT_FIXED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_ELEM_NONAME_NOREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_EXTENSION_NO_BASE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_E_PROPS_CORRECT_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_E_PROPS_CORRECT_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_E_PROPS_CORRECT_4 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_E_PROPS_CORRECT_5 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_E_PROPS_CORRECT_6 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_FACET_NO_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_FAILED_BUILD_IMPORT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_FAILED_LOAD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_FAILED_PARSE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_GROUP_NONAME_NOREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_IMPORT_NAMESPACE_NOT_URI = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_IMPORT_REDEFINE_NSNAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_IMPORT_SCHEMA_NOT_URI = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INCLUDE_SCHEMA_NOT_URI = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INCLUDE_SCHEMA_NO_URI = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INTERNAL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INVALID_ATTR_COMBINATION = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INVALID_ATTR_INLINE_COMBINATION = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INVALID_ATTR_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INVALID_ATTR_USE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INVALID_BOOLEAN = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INVALID_ENUM = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INVALID_FACET = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INVALID_FACET_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INVALID_MAXOCCURS = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INVALID_MINOCCURS = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INVALID_REF_AND_SUBTYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_INVALID_WHITE_SPACE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_MG_PROPS_CORRECT_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_MG_PROPS_CORRECT_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_MISSING_SIMPLETYPE_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_NOATTR_NOREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_NOROOT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_NOTATION_NO_NAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_NOTHING_TO_PARSE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_NOTYPE_NOREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_NOT_DETERMINISTIC = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_NOT_SCHEMA = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_NO_XMLNS = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_NO_XSI = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_PREFIX_UNDEFINED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_P_PROPS_CORRECT_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_P_PROPS_CORRECT_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_P_PROPS_CORRECT_2_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_RECURSIVE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_REDEFINED_ATTR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_REDEFINED_ATTRGROUP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_REDEFINED_ELEMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_REDEFINED_GROUP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_REDEFINED_NOTATION = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_REDEFINED_TYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_REF_AND_CONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_REF_AND_SUBTYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_REGEXP_INVALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_RESTRICTION_NONAME_NOREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_S4S_ATTR_INVALID_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_S4S_ATTR_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_S4S_ATTR_NOT_ALLOWED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_S4S_ELEM_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_S4S_ELEM_NOT_ALLOWED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SIMPLETYPE_NONAME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_ATTRIBUTE_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_ATTRIBUTE_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_ATTRIBUTE_3_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_ATTRIBUTE_3_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_ATTRIBUTE_4 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_ATTRIBUTE_GROUP_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_ATTRIBUTE_GROUP_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_ATTRIBUTE_GROUP_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_CT_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_ELEMENT_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_ELEMENT_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_ELEMENT_2_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_ELEMENT_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_IMPORT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_IMPORT_1_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_IMPORT_1_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_IMPORT_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_IMPORT_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_IMPORT_2_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_IMPORT_3_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_IMPORT_3_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_INCLUDE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_REDEFINE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_RESOLVE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_SIMPLE_TYPE_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_SIMPLE_TYPE_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_SIMPLE_TYPE_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_SIMPLE_TYPE_4 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_ST_PROPS_CORRECT_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_ST_PROPS_CORRECT_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_ST_PROPS_CORRECT_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_TYPE_AND_SUBTYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNION_NOT_EXPRESSIBLE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_ALL_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_ATTRGRP_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_ATTR_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_BASE_TYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_CHOICE_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_ELEM_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_EXTENSION_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_FACET_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_FACET_TYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_GROUP_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_IMPORT_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_INCLUDE_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_LIST_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_MEMBER_TYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_NOTATION_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_PREFIX = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_REF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_RESTRICTION_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_SCHEMAS_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_SEQUENCE_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_TYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_UNKNOWN_UNION_CHILD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_WARN_ATTR_POINTLESS_PROH = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_WARN_ATTR_REDECL_PROH = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_WARN_SKIP_SCHEMA = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_WARN_UNLOCATED_SCHEMA = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAP_WILDCARD_INVALID_NS_MEMBER = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMASP = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMASV = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMATRONV = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMATRONV_ASSERT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMATRONV_REPORT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_ATTRINVALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_ATTRUNKNOWN = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CONSTRUCT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ATTRIBUTE_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ATTRIBUTE_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ATTRIBUTE_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ATTRIBUTE_4 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_AU = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_COMPLEX_TYPE_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_COMPLEX_TYPE_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_COMPLEX_TYPE_2_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_COMPLEX_TYPE_2_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_COMPLEX_TYPE_2_4 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_COMPLEX_TYPE_3_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_COMPLEX_TYPE_3_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_COMPLEX_TYPE_3_2_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_COMPLEX_TYPE_4 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_COMPLEX_TYPE_5_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_COMPLEX_TYPE_5_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_DATATYPE_VALID_1_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_DATATYPE_VALID_1_2_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_DATATYPE_VALID_1_2_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_3_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_3_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_3_2_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_4_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_4_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_4_3 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_5_1_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_5_1_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_5_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_5_2_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_5_2_2_2_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_5_2_2_2_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_6 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ELT_7 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_ENUMERATION_VALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_FACET_VALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_FRACTIONDIGITS_VALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_IDC = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_LENGTH_VALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_MAXEXCLUSIVE_VALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_MAXINCLUSIVE_VALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_MAXLENGTH_VALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_MINEXCLUSIVE_VALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_MININCLUSIVE_VALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_MINLENGTH_VALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_PATTERN_VALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_TOTALDIGITS_VALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_TYPE_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_TYPE_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_TYPE_3_1_1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_TYPE_3_1_2 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_CVC_WILDCARD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_DOCUMENT_ELEMENT_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_ELEMCONT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_ELEMENT_CONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_EXTRACONTENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_FACET = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_HAVEDEFAULT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_INTERNAL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_INVALIDATTR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_INVALIDELEM = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_ISABSTRACT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_MISC = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_NOROLLBACK = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_NOROOT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_NOTDETERMINIST = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_NOTEMPTY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_NOTNILLABLE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_NOTSIMPLE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_NOTTOPLEVEL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_NOTYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_UNDECLAREDELEM = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SCHEMAV_WRONGELEM = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SEPARATOR_REQUIRED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::SPACE_REQUIRED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::STANDALONE_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::STRING_NOT_CLOSED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::STRING_NOT_STARTED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::TAG_NAME_MISMATCH = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::TAG_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::TREE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::TREE_INVALID_DEC = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::TREE_INVALID_HEX = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::TREE_NOT_UTF8 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::TREE_UNTERMINATED_ENTITY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::UNDECLARED_ENTITY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::UNKNOWN_ENCODING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::UNPARSED_ENTITY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::UNSUPPORTED_ENCODING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::URI_FRAGMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::URI_REQUIRED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::VALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::VALUE_REQUIRED = T.let(T.unsafe(nil), Integer)

# Verbose error handler
#
# source://libxml-ruby//lib/libxml/error.rb#28
LibXML::XML::Error::VERBOSE_HANDLER = T.let(T.unsafe(nil), Proc)

LibXML::XML::Error::VERSION_MISSING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::WARNING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::WAR_ENTITY_REDEFINED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::WAR_NS_COLUMN = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::WRITER = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_BUILD_FAILED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_DEPRECATED_NS = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_ENTITY_DEF_MISMATCH = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_FALLBACKS_IN_INCLUDE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_FALLBACK_NOT_IN_INCLUDE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_FRAGMENT_ID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_HREF_URI = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_INCLUDE_IN_INCLUDE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_INVALID_CHAR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_MULTIPLE_ROOT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_NO_FALLBACK = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_NO_HREF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_PARSE_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_RECURSION = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_TEXT_DOCUMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_TEXT_FRAGMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_UNKNOWN_ENCODING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_XPTR_FAILED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XINCLUDE_XPTR_RESULT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XMLDECL_NOT_FINISHED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XMLDECL_NOT_STARTED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XML_WAR_CATALOG_PI = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XML_WAR_LANG_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XML_WAR_NS_URI = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XML_WAR_NS_URI_RELATIVE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XML_WAR_SPACE_VALUE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XML_WAR_UNDECLARED_ENTITY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XML_WAR_UNKNOWN_VERSION = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_ENCODING_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_EXPRESSION_OK = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_EXPR_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_INVALID_ARITY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_INVALID_CHAR_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_INVALID_CTXT_POSITION = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_INVALID_CTXT_SIZE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_INVALID_OPERAND = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_INVALID_PREDICATE_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_INVALID_TYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_MEMORY_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_NUMBER_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_START_LITERAL_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_UNCLOSED_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_UNDEF_PREFIX_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_UNDEF_VARIABLE_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_UNFINISHED_LITERAL_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_UNKNOWN_FUNC_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPATH_VARIABLE_REF_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPOINTER = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPTR_CHILDSEQ_START = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPTR_EVAL_FAILED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPTR_EXTRA_OBJECTS = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPTR_RESOURCE_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPTR_SUB_RESOURCE_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPTR_SYNTAX_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XPTR_UNKNOWN_SCHEME = T.let(T.unsafe(nil), Integer)
LibXML::XML::Error::XSLT = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/html_parser.rb#5
class LibXML::XML::HTMLParser
  def initialize(*_arg0); end

  # :enddoc:
  #
  # source://libxml-ruby//lib/libxml/html_parser.rb#80
  def file=(value); end

  def input; end

  # source://libxml-ruby//lib/libxml/html_parser.rb#85
  def io=(value); end

  def parse; end

  # source://libxml-ruby//lib/libxml/html_parser.rb#90
  def string=(value); end

  class << self
    # call-seq:
    #    XML::HTMLParser.file(path) -> XML::HTMLParser
    #    XML::HTMLParser.file(path, :encoding => XML::Encoding::UTF_8,
    #                           :options => XML::HTMLParser::Options::NOENT) -> XML::HTMLParser
    #
    # Creates a new parser by parsing the specified file or uri.
    #
    # You may provide an optional hash table to control how the
    # parsing is performed.  Valid options are:
    #
    #  encoding - The document encoding, defaults to nil. Valid values
    #             are the encoding constants defined on XML::Encoding.
    #  options - Parser options.  Valid values are the constants defined on
    #            XML::HTMLParser::Options.  Mutliple options can be combined
    #            by using Bitwise OR (|).
    #
    # source://libxml-ruby//lib/libxml/html_parser.rb#21
    def file(path, options = T.unsafe(nil)); end

    # call-seq:
    #    XML::HTMLParser.io(io) -> XML::HTMLParser
    #    XML::HTMLParser.io(io, :encoding => XML::Encoding::UTF_8,
    #                       :options => XML::HTMLParser::Options::NOENT
    #                       :base_uri="http://libxml.org") -> XML::HTMLParser
    #
    # Creates a new reader by parsing the specified io object.
    #
    # Parameters:
    #
    #  io - io object that contains the xml to parser
    #  base_uri - The base url for the parsed document.
    #  encoding - The document encoding, defaults to nil. Valid values
    #             are the encoding constants defined on XML::Encoding.
    #  options - Parser options.  Valid values are the constants defined on
    #            XML::HTMLParser::Options.  Mutliple options can be combined
    #            by using Bitwise OR (|).
    #
    # source://libxml-ruby//lib/libxml/html_parser.rb#45
    def io(io, options = T.unsafe(nil)); end

    # call-seq:
    #    XML::HTMLParser.string(string)
    #    XML::HTMLParser.string(string, :encoding => XML::Encoding::UTF_8,
    #                               :options => XML::HTMLParser::Options::NOENT
    #                               :base_uri="http://libxml.org") -> XML::HTMLParser
    #
    # Creates a new parser by parsing the specified string.
    #
    # You may provide an optional hash table to control how the
    # parsing is performed.  Valid options are:
    #
    #  base_uri - The base url for the parsed document.
    #  encoding - The document encoding, defaults to nil. Valid values
    #             are the encoding constants defined on XML::Encoding.
    #  options - Parser options.  Valid values are the constants defined on
    #            XML::HTMLParser::Options.  Mutliple options can be combined
    #            by using Bitwise OR (|).
    #
    # source://libxml-ruby//lib/libxml/html_parser.rb#70
    def string(string, options = T.unsafe(nil)); end
  end
end

class LibXML::XML::HTMLParser::Context < ::LibXML::XML::Parser::Context
  def close; end
  def disable_cdata=(_arg0); end
  def options=(_arg0); end

  class << self
    def file(_arg0); end
    def io(_arg0); end
    def string(_arg0); end
  end
end

module LibXML::XML::HTMLParser::Options; end
LibXML::XML::HTMLParser::Options::COMPACT = T.let(T.unsafe(nil), Integer)
LibXML::XML::HTMLParser::Options::NOBLANKS = T.let(T.unsafe(nil), Integer)
LibXML::XML::HTMLParser::Options::NODEFDTD = T.let(T.unsafe(nil), Integer)
LibXML::XML::HTMLParser::Options::NOERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::HTMLParser::Options::NOIMPLIED = T.let(T.unsafe(nil), Integer)
LibXML::XML::HTMLParser::Options::NONET = T.let(T.unsafe(nil), Integer)
LibXML::XML::HTMLParser::Options::NOWARNING = T.let(T.unsafe(nil), Integer)
LibXML::XML::HTMLParser::Options::PEDANTIC = T.let(T.unsafe(nil), Integer)
LibXML::XML::HTMLParser::Options::RECOVER = T.let(T.unsafe(nil), Integer)

class LibXML::XML::InputCallbacks
  class << self
    def add_scheme(_arg0, _arg1); end
    def register; end
    def remove_scheme(_arg0); end
  end
end

LibXML::XML::LIBXML_VERSION = T.let(T.unsafe(nil), String)

# source://libxml-ruby//lib/libxml/namespace.rb#5
class LibXML::XML::Namespace
  include ::Comparable
  include ::Enumerable

  def initialize(_arg0, _arg1, _arg2); end

  # call-seq:
  #   namespace1 <=> namespace2
  #
  # Compares two namespace objects.  Namespace objects are
  # considered equal if their prefixes and hrefs are the same.
  #
  # source://libxml-ruby//lib/libxml/namespace.rb#14
  def <=>(other); end

  # call-seq:
  #   namespace.each {|ns| .. }
  #
  # libxml stores namespaces in memory as a linked list.
  # Use the each method to iterate over the list.  Note
  # the first namespace in the loop is the current namespace.
  #
  # Usage:
  #   namespace.each do |ns|
  #     ..
  #   end
  #
  # source://libxml-ruby//lib/libxml/namespace.rb#37
  def each; end

  def href; end
  def next; end
  def node_type; end
  def prefix; end

  # call-seq:
  #   namespace.to_s -> "string"
  #
  # Returns the string represenation of a namespace.
  #
  # Usage:
  #   namespace.to_s
  #
  # source://libxml-ruby//lib/libxml/namespace.rb#53
  def to_s; end
end

# source://libxml-ruby//lib/libxml/namespaces.rb#5
class LibXML::XML::Namespaces
  include ::Enumerable

  def initialize(_arg0); end

  # call-seq:
  #   namespace.default -> XML::Namespace
  #
  # Returns the default namespace for this node or nil.
  #
  # Usage:
  #   doc = XML::Document.string('<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"/>')
  #   ns = doc.root.namespaces.default_namespace
  #   assert_equal(ns.href, 'http://schemas.xmlsoap.org/soap/envelope/')
  #
  # source://libxml-ruby//lib/libxml/namespaces.rb#15
  def default; end

  # call-seq:
  #   namespace.default_prefix = "string"
  #
  # Assigns a name (prefix) to the default namespace.
  # This makes it much easier to perform XML::XPath
  # searches.
  #
  # Usage:
  #   doc = XML::Document.string('<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"/>')
  #   doc.root.namespaces.default_prefix = 'soap'
  #   node = doc.root.find_first('soap:Envelope')
  #
  # @raise [ArgumentError]
  #
  # source://libxml-ruby//lib/libxml/namespaces.rb#30
  def default_prefix=(prefix); end

  def definitions; end
  def each; end
  def find_by_href(_arg0); end
  def find_by_prefix(_arg0); end
  def namespace; end
  def namespace=(_arg0); end
  def node; end
end

# source://libxml-ruby//lib/libxml/node.rb#7
class LibXML::XML::Node
  include ::Enumerable

  def initialize(*_arg0); end

  def <<(_arg0); end
  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end

  # Specifies if this is an attribute node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#207
  def attribute?; end

  # Specifies if this is an attribute declaration node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#212
  def attribute_decl?; end

  def attributes; end

  # Determines whether this node has attributes
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#9
  def attributes?; end

  def base_uri; end
  def base_uri=(_arg0); end
  def blank?; end

  # Specifies if this is an CDATA node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#217
  def cdata?; end

  def child; end

  # Determines whether this node has a first node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#126
  def child?; end

  # Returns this node's children as an array.
  #
  # source://libxml-ruby//lib/libxml/node.rb#131
  def children; end

  # Determines whether this node has a first node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#126
  def children?; end

  # Create a shallow copy of the node.  To create
  # a deep copy call Node#copy(true)
  #
  # source://libxml-ruby//lib/libxml/node.rb#15
  def clone; end

  # Specifies if this is an comment node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#222
  def comment?; end

  def content; end
  def content=(_arg0); end

  # call-seq:
  #   node.context(namespaces=nil) -> XPath::Context
  #
  # Returns a new XML::XPathContext for the current node.
  #
  # Namespaces is an optional array of XML::NS objects
  #
  # source://libxml-ruby//lib/libxml/node.rb#53
  def context(nslist = T.unsafe(nil)); end

  def copy(_arg0); end
  def debug; end
  def doc; end

  # Specifies if this is an docbook node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#227
  def docbook_doc?; end

  # Specifies if this is an doctype node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#232
  def doctype?; end

  # Specifies if this is an document node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#237
  def document?; end

  # Specifies if this is an DTD node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#242
  def dtd?; end

  # :call-seq:
  #   node.dup -> XML::Node
  #
  # Create a shallow copy of the node.  To create
  # a deep copy call Node#copy(true)
  #
  # source://libxml-ruby//lib/libxml/node.rb#43
  def dup; end

  def each; end

  # -------  Traversal  ----------------
  # Iterates over this node's attributes.
  #
  #  doc = XML::Document.new('model/books.xml')
  #  doc.root.each_attr {|attr| puts attr}
  #
  # source://libxml-ruby//lib/libxml/node.rb#103
  def each_attr; end

  def each_child; end

  # Iterates over this node's child elements (nodes
  # that have a node_type == ELEMENT_NODE).
  #
  #  doc = XML::Document.new('model/books.xml')
  #  doc.root.each_element {|element| puts element}
  #
  # source://libxml-ruby//lib/libxml/node.rb#114
  def each_element; end

  # Specifies if this is an element node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#247
  def element?; end

  # Specifies if this is an element declaration node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#257
  def element_decl?; end

  def empty?; end

  # Specifies if this is an entity node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#252
  def entity?; end

  # Specifies if this is an entity reference node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#262
  def entity_ref?; end

  def eql?(_arg0); end

  # call-seq:
  #   node.find(namespaces=nil) -> XPath::XPathObject
  #
  # Return nodes matching the specified xpath expression.
  # For more information, please refer to the documentation
  # for XML::Document#find.
  #
  # Namespaces is an optional array of XML::NS objects
  #
  # source://libxml-ruby//lib/libxml/node.rb#74
  def find(xpath, nslist = T.unsafe(nil)); end

  # call-seq:
  #   node.find_first(namespaces=nil) -> XML::Node
  #
  # Return the first node matching the specified xpath expression.
  # For more information, please refer to the documentation
  # for the #find method.
  #
  # source://libxml-ruby//lib/libxml/node.rb#84
  def find_first(xpath, nslist = T.unsafe(nil)); end

  def first; end

  # Determines whether this node has a first node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#126
  def first?; end

  # Specifies if this is a fragment node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#267
  def fragment?; end

  # Specifies if this is a html document node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#272
  def html_doc?; end

  # call-seq:
  #    node.inner_xml -> "string"
  #    node.inner_xml(:indent => true, :encoding => 'UTF-8', :level => 0) -> "string"
  #
  # Converts a node's children to a string representation.  To include
  # the node, use XML::Node#to_s.  For more information about
  # the supported options, see XML::Node#to_s.
  #
  # source://libxml-ruby//lib/libxml/node.rb#26
  def inner_xml(options = T.unsafe(nil)); end

  def lang; end
  def lang=(_arg0); end
  def last; end

  # Determines whether this node has a last node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#146
  def last?; end

  def line_num; end
  def name; end
  def name=(_arg0); end

  # Specifies if this is a namespace node (not if it
  # has a namepsace)
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#278
  def namespace?; end

  # call-seq:
  #   node.namespacess -> XML::Namespaces
  #
  # Returns this node's XML::Namespaces object,
  # which is used to access the namespaces
  # associated with this node.
  #
  # source://libxml-ruby//lib/libxml/node.rb#94
  def namespaces; end

  def next; end
  def next=(_arg0); end

  # Determines whether this node has a next node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#136
  def next?; end

  def node_type; end

  # Returns this node's type name
  #
  # source://libxml-ruby//lib/libxml/node.rb#154
  def node_type_name; end

  # Specifies if this is a notation node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#283
  def notation?; end

  def output_escaping=(_arg0); end
  def output_escaping?; end
  def parent; end

  # Determines whether this node has a parent node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#121
  def parent?; end

  def path; end

  # Specifies if this is a processiong instruction node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#288
  def pi?; end

  def prev; end
  def prev=(_arg0); end

  # Determines whether this node has a previous node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#141
  def prev?; end

  def remove!; end
  def sibling=(_arg0); end
  def space_preserve; end
  def space_preserve=(_arg0); end

  # Specifies if this is a text node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#293
  def text?; end

  def to_s(*_arg0); end

  # Specifies if this is an xinclude end node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#298
  def xinclude_end?; end

  # Specifies if this is an xinclude start node
  #
  # @return [Boolean]
  #
  # source://libxml-ruby//lib/libxml/node.rb#303
  def xinclude_start?; end

  def xlink?; end
  def xlink_type; end
  def xlink_type_name; end

  private

  # source://libxml-ruby//lib/libxml/node.rb#314
  def create_string_io(xml); end

  class << self
    def new_cdata(*_arg0); end
    def new_comment(*_arg0); end
    def new_pi(*_arg0); end
    def new_text(_arg0); end
  end
end

LibXML::XML::Node::ATTRIBUTE_DECL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::ATTRIBUTE_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::CDATA_SECTION_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::COMMENT_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::DOCB_DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::DOCUMENT_FRAG_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::DOCUMENT_TYPE_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::DTD_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::ELEMENT_DECL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::ELEMENT_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::ENTITY_DECL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::ENTITY_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::ENTITY_REF_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::HTML_DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::NAMESPACE_DECL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::NOTATION_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::PI_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::SPACE_DEFAULT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::SPACE_NOT_INHERIT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::SPACE_PRESERVE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::TEXT_NODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::XINCLUDE_END = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::XINCLUDE_START = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::XLINK_ACTUATE_AUTO = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::XLINK_ACTUATE_NONE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::XLINK_ACTUATE_ONREQUEST = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::XLINK_SHOW_EMBED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::XLINK_SHOW_NEW = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::XLINK_SHOW_NONE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::XLINK_SHOW_REPLACE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::XLINK_TYPE_EXTENDED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::XLINK_TYPE_EXTENDED_SET = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::XLINK_TYPE_NONE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Node::XLINK_TYPE_SIMPLE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/parser.rb#5
class LibXML::XML::Parser
  def initialize(*_arg0); end

  def context; end
  def input; end
  def parse; end

  class << self
    # call-seq:
    #    XML::Parser.document(document) -> XML::Parser
    #
    # Creates a new parser for the specified document.
    #
    # Parameters:
    #
    #  document - A preparsed document.
    #
    # source://libxml-ruby//lib/libxml/parser.rb#14
    def document(doc); end

    # call-seq:
    #    XML::Parser.file(path) -> XML::Parser
    #    XML::Parser.file(path, :encoding => XML::Encoding::UTF_8,
    #                           :options => XML::Parser::Options::NOENT) -> XML::Parser
    #
    # Creates a new parser for the specified file or uri.
    #
    # You may provide an optional hash table to control how the
    # parsing is performed.  Valid options are:
    #
    #  encoding - The document encoding, defaults to nil. Valid values
    #             are the encoding constants defined on XML::Encoding.
    #  options - Parser options.  Valid values are the constants defined on
    #            XML::Parser::Options.  Mutliple options can be combined
    #            by using Bitwise OR (|).
    #
    # source://libxml-ruby//lib/libxml/parser.rb#34
    def file(path, options = T.unsafe(nil)); end

    # call-seq:
    #    XML::Parser.io(io) -> XML::Parser
    #    XML::Parser.io(io, :encoding => XML::Encoding::UTF_8,
    #                       :options => XML::Parser::Options::NOENT
    #                       :base_uri="http://libxml.org") -> XML::Parser
    #
    # Creates a new parser for the specified io object.
    #
    # Parameters:
    #
    #  io - io object that contains the xml to parser
    #  base_uri - The base url for the parsed document.
    #  encoding - The document encoding, defaults to nil. Valid values
    #             are the encoding constants defined on XML::Encoding.
    #  options - Parser options.  Valid values are the constants defined on
    #            XML::Parser::Options.  Mutliple options can be combined
    #            by using Bitwise OR (|).
    #
    # source://libxml-ruby//lib/libxml/parser.rb#58
    def io(io, options = T.unsafe(nil)); end

    # source://libxml-ruby//lib/libxml/parser.rb#91
    def register_error_handler(proc); end

    # call-seq:
    #    XML::Parser.string(string)
    #    XML::Parser.string(string, :encoding => XML::Encoding::UTF_8,
    #                               :options => XML::Parser::Options::NOENT
    #                               :base_uri="http://libxml.org") -> XML::Parser
    #
    # Creates a new parser by parsing the specified string.
    #
    # You may provide an optional hash table to control how the
    # parsing is performed.  Valid options are:
    #
    #  base_uri - The base url for the parsed document.
    #  encoding - The document encoding, defaults to nil. Valid values
    #             are the encoding constants defined on XML::Encoding.
    #  options - Parser options.  Valid values are the constants defined on
    #            XML::Parser::Options.  Mutliple options can be combined
    #            by using Bitwise OR (|).
    #
    # source://libxml-ruby//lib/libxml/parser.rb#83
    def string(string, options = T.unsafe(nil)); end
  end
end

class LibXML::XML::Parser::Context
  def base_uri; end
  def base_uri=(_arg0); end
  def close; end
  def data_directory; end
  def depth; end
  def disable_cdata=(_arg0); end
  def disable_cdata?; end
  def disable_sax?; end
  def docbook?; end
  def encoding; end
  def encoding=(_arg0); end
  def errno; end
  def html?; end
  def io_max_num_streams; end
  def io_num_streams; end
  def keep_blanks?; end
  def name_depth; end
  def name_depth_max; end
  def name_node; end
  def name_tab; end
  def node; end
  def node_depth; end
  def node_depth_max; end
  def num_chars; end
  def options; end
  def options=(_arg0); end
  def recovery=(_arg0); end
  def recovery?; end
  def replace_entities=(_arg0); end
  def replace_entities?; end
  def space_depth; end
  def space_depth_max; end
  def standalone?; end
  def stats?; end
  def subset_external?; end
  def subset_external_system_id; end
  def subset_external_uri; end
  def subset_internal?; end
  def subset_internal_name; end
  def valid; end
  def validate?; end
  def version; end
  def well_formed?; end

  class << self
    def document(_arg0); end
    def file(_arg0); end
    def io(_arg0); end
    def string(_arg0); end
  end
end

module LibXML::XML::Parser::Options; end
LibXML::XML::Parser::Options::COMPACT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::DTDATTR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::DTDLOAD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::DTDVALID = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::HUGE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::NOBASEFIX = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::NOBLANKS = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::NOCDATA = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::NODICT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::NOENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::NOERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::NONET = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::NOWARNING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::NOXINCNODE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::NSCLEAN = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::PARSE_OLD10 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::PEDANTIC = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::RECOVER = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::SAX1 = T.let(T.unsafe(nil), Integer)
LibXML::XML::Parser::Options::XINCLUDE = T.let(T.unsafe(nil), Integer)

class LibXML::XML::Reader
  def [](_arg0); end
  def attribute_count; end
  def base_uri; end
  def byte_consumed; end
  def close; end
  def column_number; end
  def default?; end
  def depth; end
  def doc; end
  def empty_element?; end
  def encoding; end
  def expand; end
  def get_attribute(_arg0); end
  def get_attribute_no(_arg0); end
  def get_attribute_ns(_arg0, _arg1); end
  def has_attributes?; end
  def has_value?; end
  def line_number; end
  def local_name; end
  def lookup_namespace(_arg0); end
  def move_to_attribute(_arg0); end
  def move_to_attribute_no(_arg0); end
  def move_to_attribute_ns(_arg0, _arg1); end
  def move_to_element; end
  def move_to_first_attribute; end
  def move_to_next_attribute; end
  def name; end
  def namespace_declaration?; end
  def namespace_uri; end
  def next; end
  def next_sibling; end
  def node; end
  def node_type; end
  def normalization; end
  def prefix; end
  def quote_char; end
  def read; end
  def read_attribute_value; end
  def read_inner_xml; end
  def read_outer_xml; end
  def read_state; end
  def read_string; end
  def relax_ng_validate(_arg0); end
  def schema_validate(_arg0); end
  def standalone; end
  def valid?; end
  def value; end
  def xml_lang; end
  def xml_version; end

  class << self
    def document(_arg0); end
    def file(*_arg0); end
    def io(*_arg0); end
    def string(*_arg0); end
  end
end

LibXML::XML::Reader::DEFAULTATTRS = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::LOADDTD = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::MODE_CLOSED = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::MODE_EOF = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::MODE_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::MODE_INITIAL = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::MODE_INTERACTIVE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::MODE_READING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::SEVERITY_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::SEVERITY_VALIDITY_ERROR = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::SEVERITY_VALIDITY_WARNING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::SEVERITY_WARNING = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::SUBST_ENTITIES = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_ATTRIBUTE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_CDATA = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_COMMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_DOCUMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_DOCUMENT_FRAGMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_DOCUMENT_TYPE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_ELEMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_END_ELEMENT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_END_ENTITY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_ENTITY = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_ENTITY_REFERENCE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_NONE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_NOTATION = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_PROCESSING_INSTRUCTION = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_SIGNIFICANT_WHITESPACE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_TEXT = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_WHITESPACE = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::TYPE_XML_DECLARATION = T.let(T.unsafe(nil), Integer)
LibXML::XML::Reader::VALIDATE = T.let(T.unsafe(nil), Integer)

class LibXML::XML::RelaxNG
  class << self
    def document(_arg0); end
    def from_string(_arg0); end
    def new(_arg0); end
  end
end

# source://libxml-ruby//lib/libxml/sax_parser.rb#5
class LibXML::XML::SaxParser
  def initialize(*_arg0); end

  def callbacks; end
  def callbacks=(_arg0); end
  def parse; end

  class << self
    # call-seq:
    #    XML::SaxParser.file(path) -> XML::SaxParser
    #
    # Creates a new parser by parsing the specified file or uri.
    #
    # source://libxml-ruby//lib/libxml/sax_parser.rb#10
    def file(path); end

    # call-seq:
    #    XML::SaxParser.io(io) -> XML::SaxParser
    #    XML::SaxParser.io(io, :encoding => XML::Encoding::UTF_8) -> XML::SaxParser
    #
    # Creates a new reader by parsing the specified io object.
    #
    # Parameters:
    #
    #  encoding - The document encoding, defaults to nil. Valid values
    #             are the encoding constants defined on XML::Encoding.
    #
    # source://libxml-ruby//lib/libxml/sax_parser.rb#25
    def io(io, options = T.unsafe(nil)); end

    # call-seq:
    #    XML::SaxParser.string(string)
    #
    # Creates a new parser by parsing the specified string.
    #
    # source://libxml-ruby//lib/libxml/sax_parser.rb#35
    def string(string); end
  end
end

# source://libxml-ruby//lib/libxml/sax_callbacks.rb#6
module LibXML::XML::SaxParser::Callbacks
  # Called for a CDATA block event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#8
  def on_cdata_block(cdata); end

  # Called for a characters event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#12
  def on_characters(chars); end

  # Called for a comment event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#16
  def on_comment(msg); end

  # Called for a end document event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#20
  def on_end_document; end

  # Called for a end element event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#24
  def on_end_element_ns(name, prefix, uri); end

  # Called for parser errors.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#28
  def on_error(msg); end

  # Called for an external subset event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#32
  def on_external_subset(name, external_id, system_id); end

  # Called for an external subset notification event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#36
  def on_has_external_subset; end

  # Called for an internal subset notification event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#40
  def on_has_internal_subset; end

  # Called for an internal subset event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#44
  def on_internal_subset(name, external_id, system_id); end

  # Called for 'is standalone' event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#48
  def on_is_standalone; end

  # Called for an processing instruction event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#52
  def on_processing_instruction(target, data); end

  # Called for a reference event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#56
  def on_reference(name); end

  # Called for a start document event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#60
  def on_start_document; end

  # Called for a start element event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#64
  def on_start_element_ns(name, attributes, prefix, uri, namespaces); end
end

# source://libxml-ruby//lib/libxml/sax_callbacks.rb#68
module LibXML::XML::SaxParser::VerboseCallbacks
  # Called for a CDATA block event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#70
  def on_cdata_block(cdata); end

  # Called for a characters event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#77
  def on_characters(chars); end

  # Called for a comment event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#84
  def on_comment(comment); end

  # Called for a end document event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#91
  def on_end_document; end

  # Called for a end element event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#97
  def on_end_element_ns(name, prefix, uri); end

  # Called for parser errors.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#106
  def on_error(error); end

  # Called for an external subset event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#113
  def on_external_subset(name, external_id, system_id); end

  # Called for an external subset notification event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#121
  def on_has_external_subset; end

  # Called for an internal subset notification event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#127
  def on_has_internal_subset; end

  # Called for an internal subset event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#133
  def on_internal_subset(name, external_id, system_id); end

  # Called for 'is standalone' event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#141
  def on_is_standalone; end

  # Called for an processing instruction event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#147
  def on_processing_instruction(target, data); end

  # Called for a reference event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#155
  def on_reference(name); end

  # Called for a start document event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#162
  def on_start_document; end

  # Called for a start element event.
  #
  # source://libxml-ruby//lib/libxml/sax_callbacks.rb#168
  def on_start_element_ns(name, attributes, prefix, uri, namespaces); end
end

# source://libxml-ruby//lib/libxml/schema.rb#3
class LibXML::XML::Schema
  def document; end
  def elements; end
  def id; end
  def imported_ns_elements; end
  def imported_ns_types; end
  def imported_types; end
  def name; end
  def namespaces; end
  def target_namespace; end
  def types; end
  def version; end

  class << self
    def document(_arg0); end
    def from_string(_arg0); end
    def new(_arg0); end
  end
end

# source://libxml-ruby//lib/libxml/schema/attribute.rb#5
class LibXML::XML::Schema::Attribute
  # source://libxml-ruby//lib/libxml/schema/attribute.rb#9
  def default; end

  def name; end
  def namespace; end
  def node; end
  def occurs; end

  # source://libxml-ruby//lib/libxml/schema/attribute.rb#13
  def required?; end

  def type; end
  def value; end
end

# source://libxml-ruby//lib/libxml/schema/attribute.rb#7
LibXML::XML::Schema::Attribute::OPTIONAL = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema/attribute.rb#6
LibXML::XML::Schema::Attribute::REQUIRED = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema/element.rb#5
class LibXML::XML::Schema::Element
  def annotation; end

  # source://libxml-ruby//lib/libxml/schema/element.rb#10
  def array?; end

  # source://libxml-ruby//lib/libxml/schema/element.rb#14
  def elements; end

  def name; end
  def namespace; end
  def node; end

  # source://libxml-ruby//lib/libxml/schema/element.rb#6
  def required?; end

  def type; end
  def value; end
end

class LibXML::XML::Schema::Facet
  def kind; end
  def node; end
  def value; end
end

# source://libxml-ruby//lib/libxml/schema/type.rb#3
class LibXML::XML::Schema::Type
  # source://libxml-ruby//lib/libxml/schema/type.rb#8
  def annonymus_subtypes; end

  # source://libxml-ruby//lib/libxml/schema/type.rb#12
  def annonymus_subtypes_recursively(parent = T.unsafe(nil)); end

  def annotation; end
  def attributes; end
  def base; end
  def elements; end
  def facets; end
  def kind; end

  # source://libxml-ruby//lib/libxml/schema/type.rb#4
  def kind_name; end

  def name; end
  def namespace; end
  def node; end
end

# source://libxml-ruby//lib/libxml/schema.rb#4
module LibXML::XML::Schema::Types; end

# source://libxml-ruby//lib/libxml/schema.rb#44
LibXML::XML::Schema::Types::XML_SCHEMA_EXTRA_ATTR_USE_PROHIB = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#43
LibXML::XML::Schema::Types::XML_SCHEMA_EXTRA_QNAMEREF = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#38
LibXML::XML::Schema::Types::XML_SCHEMA_FACET_ENUMERATION = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#36
LibXML::XML::Schema::Types::XML_SCHEMA_FACET_FRACTIONDIGITS = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#40
LibXML::XML::Schema::Types::XML_SCHEMA_FACET_LENGTH = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#34
LibXML::XML::Schema::Types::XML_SCHEMA_FACET_MAXEXCLUSIVE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#33
LibXML::XML::Schema::Types::XML_SCHEMA_FACET_MAXINCLUSIVE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#41
LibXML::XML::Schema::Types::XML_SCHEMA_FACET_MAXLENGTH = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#32
LibXML::XML::Schema::Types::XML_SCHEMA_FACET_MINEXCLUSIVE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#31
LibXML::XML::Schema::Types::XML_SCHEMA_FACET_MININCLUSIVE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#42
LibXML::XML::Schema::Types::XML_SCHEMA_FACET_MINLENGTH = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#37
LibXML::XML::Schema::Types::XML_SCHEMA_FACET_PATTERN = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#35
LibXML::XML::Schema::Types::XML_SCHEMA_FACET_TOTALDIGITS = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#39
LibXML::XML::Schema::Types::XML_SCHEMA_FACET_WHITESPACE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#12
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_ALL = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#6
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_ANY = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#25
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_ANY_ATTRIBUTE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#19
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_ATTRIBUTE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#20
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_ATTRIBUTEGROUP = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#30
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_ATTRIBUTE_USE = T.let(T.unsafe(nil), Integer)

# A built-in datatype
#
# source://libxml-ruby//lib/libxml/schema.rb#5
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_BASIC = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#11
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_CHOICE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#9
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_COMPLEX = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#14
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_COMPLEX_CONTENT = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#18
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_ELEMENT = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#17
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_EXTENSION = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#7
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_FACET = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#21
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_GROUP = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#27
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_IDC_KEY = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#28
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_IDC_KEYREF = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#26
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_IDC_UNIQUE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#23
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_LIST = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#22
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_NOTATION = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#29
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_PARTICLE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#16
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_RESTRICTION = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#10
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_SEQUENCE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#8
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_SIMPLE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#13
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_SIMPLE_CONTENT = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#24
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_UNION = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/schema.rb#15
LibXML::XML::Schema::Types::XML_SCHEMA_TYPE_UR = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#5
class LibXML::XML::Tree; end

# source://libxml-ruby//lib/libxml/tree.rb#21
LibXML::XML::Tree::ATTRIBUTE_DECL = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#7
LibXML::XML::Tree::ATTRIBUTE_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#9
LibXML::XML::Tree::CDATA_SECTION_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#13
LibXML::XML::Tree::COMMENT_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#26
LibXML::XML::Tree::DOCB_DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#16
LibXML::XML::Tree::DOCUMENT_FRAG_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#14
LibXML::XML::Tree::DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#15
LibXML::XML::Tree::DOCUMENT_TYPE_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#19
LibXML::XML::Tree::DTD_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#20
LibXML::XML::Tree::ELEMENT_DECL = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#6
LibXML::XML::Tree::ELEMENT_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#22
LibXML::XML::Tree::ENTITY_DECL = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#11
LibXML::XML::Tree::ENTITY_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#10
LibXML::XML::Tree::ENTITY_REF_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#18
LibXML::XML::Tree::HTML_DOCUMENT_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#23
LibXML::XML::Tree::NAMESPACE_DECL = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#17
LibXML::XML::Tree::NOTATION_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#12
LibXML::XML::Tree::PI_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#8
LibXML::XML::Tree::TEXT_NODE = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#25
LibXML::XML::Tree::XINCLUDE_END = T.let(T.unsafe(nil), Integer)

# source://libxml-ruby//lib/libxml/tree.rb#24
LibXML::XML::Tree::XINCLUDE_START = T.let(T.unsafe(nil), Integer)

LibXML::XML::VERNUM = T.let(T.unsafe(nil), Integer)
LibXML::XML::VERSION = T.let(T.unsafe(nil), String)

class LibXML::XML::Writer
  def end_attribute; end
  def end_cdata; end
  def end_comment; end
  def end_document; end
  def end_dtd; end
  def end_dtd_attlist; end
  def end_dtd_element; end
  def end_dtd_entity; end
  def end_element; end
  def end_pi; end
  def flush(*_arg0); end
  def full_end_element; end
  def result; end
  def set_indent(_arg0); end
  def set_indent_string(_arg0); end
  def set_quote_char(_arg0); end
  def start_attribute(_arg0); end
  def start_attribute_ns(*_arg0); end
  def start_cdata; end
  def start_comment; end
  def start_document(*_arg0); end
  def start_dtd(*_arg0); end
  def start_dtd_attlist(_arg0); end
  def start_dtd_element(_arg0); end
  def start_dtd_entity(*_arg0); end
  def start_element(_arg0); end
  def start_element_ns(*_arg0); end
  def start_pi(_arg0); end
  def write_attribute(_arg0, _arg1); end
  def write_attribute_ns(*_arg0); end
  def write_cdata(_arg0); end
  def write_comment(_arg0); end
  def write_dtd(*_arg0); end
  def write_dtd_attlist(_arg0, _arg1); end
  def write_dtd_element(_arg0, _arg1); end
  def write_dtd_entity(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5); end
  def write_dtd_external_entity(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def write_dtd_external_entity_contents(_arg0, _arg1, _arg2); end
  def write_dtd_internal_entity(_arg0, _arg1, _arg2); end
  def write_dtd_notation(_arg0, _arg1, _arg2); end
  def write_element(*_arg0); end
  def write_element_ns(*_arg0); end
  def write_pi(_arg0, _arg1); end
  def write_raw(_arg0); end
  def write_string(_arg0); end

  class << self
    def document; end
    def file(_arg0); end
    def io(_arg0); end
    def string; end
  end
end

class LibXML::XML::XInclude; end
LibXML::XML::XML_NAMESPACE = T.let(T.unsafe(nil), String)
module LibXML::XML::XPath; end
LibXML::XML::XPath::BOOLEAN = T.let(T.unsafe(nil), Integer)

class LibXML::XML::XPath::Context
  def initialize(_arg0); end

  def disable_cache; end
  def doc; end
  def enable_cache(*_arg0); end
  def find(_arg0); end
  def node=(_arg0); end
  def register_namespace(_arg0, _arg1); end
  def register_namespaces(_arg0); end
  def register_namespaces_from_node(_arg0); end
end

class LibXML::XML::XPath::Expression
  def initialize(_arg0); end

  class << self
    def compile(_arg0); end
  end
end

LibXML::XML::XPath::LOCATIONSET = T.let(T.unsafe(nil), Integer)
LibXML::XML::XPath::NODESET = T.let(T.unsafe(nil), Integer)
LibXML::XML::XPath::NUMBER = T.let(T.unsafe(nil), Integer)

class LibXML::XML::XPath::Object
  include ::Enumerable

  def [](_arg0); end
  def context; end
  def debug; end
  def each; end
  def empty?; end
  def first; end
  def last; end
  def length; end
  def size; end
  def string; end
  def to_a; end
  def xpath_type; end
end

LibXML::XML::XPath::POINT = T.let(T.unsafe(nil), Integer)
LibXML::XML::XPath::RANGE = T.let(T.unsafe(nil), Integer)
LibXML::XML::XPath::STRING = T.let(T.unsafe(nil), Integer)
LibXML::XML::XPath::UNDEFINED = T.let(T.unsafe(nil), Integer)
LibXML::XML::XPath::USERS = T.let(T.unsafe(nil), Integer)
LibXML::XML::XPath::XSLT_TREE = T.let(T.unsafe(nil), Integer)
